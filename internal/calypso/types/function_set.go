package types

import "fmt"

type FunctionList []*Function
type FunctionSet struct {
	name      string
	Instances FunctionList
}

func (s *FunctionSet) clyT() {}
func (s *FunctionSet) String() string {
	msg := fmt.Sprintf("<FunctionSet> %s\n", s.Name())

	for _, fn := range s.Instances {
		msg += fmt.Sprintf("\t\t%s\n", fn.Type())
	}

	return msg
}

func (s *FunctionSet) Name() string {
	return s.name
}
func (s *FunctionSet) Type() Type {
	return s
}
func (s *FunctionSet) Parent() Type {
	return s
}

func NewFunctionSet(fn *Function) *FunctionSet {
	return &FunctionSet{
		name:      fn.name,
		Instances: FunctionList{fn},
	}
}

func (s *FunctionSet) GetAsSingle() (*Function, bool) {
	if len(s.Instances) == 1 {
		return s.Instances[0], true
	}

	return nil, false
}

func (s *FunctionSet) Add(fn *Function) error {

	sg := fn.Sg()

	if sg == nil {
		return fmt.Errorf("invalid function signature: %s", fn.Type())
	}

	cr := s.Find(sg, true)

	if cr != nil {
		return fmt.Errorf("invalid redeclaration of \"%s\"", fn.Name())
	}

	creator := s.Instances[0]

	// ensure function has the same return type
	_, err := Validate(creator.Sg().Result.Type(), sg.Result.Type())

	if err != nil {
		return err
	}

	s.Instances = append(s.Instances, fn)
	return nil
}

// will return a new function set containing what possible functions could match the provided signature
func (s *FunctionSet) Find(sg *FunctionSignature, strict bool) *FunctionSet {
	if sg == nil {
		return nil
	}

	var set *FunctionSet

	for _, fn := range s.Instances {
		if s.Compare(sg, fn.Sg(), strict) {
			if set == nil {
				set = NewFunctionSet(fn)
			} else {
				set.Instances = append(set.Instances, fn)
			}
		}
	}

	return set
}

/*
This method is called ona function set generated by the `Find` function to pick the best option, take the signatures below

`fn update(name: string){}`

`fn update<T>(name: T) {}`
*/
func (s *FunctionSet) MostSpecialized() Type {
	// Only contains one option, return that option
	single, ok := s.GetAsSingle()
	if ok {
		return single.Sg()
	}

	// has multiple options, pick non generic options
	options := []Type{}

	for _, fn := range s.Instances {
		if IsGeneric(fn.Sg()) {
			continue
		}

		options = append(options, fn.Sg())
	}

	if len(options) == 1 {
		return options[0]
	}

	// multiple signatures can still resolve in this trimmed set, return the set
	return s
}

func (s *FunctionSet) Compare(provided, expected *FunctionSignature, strict bool) bool {

	// when strict, ensure the return types match [Function Decl]
	// is non-strict is call expression matching
	if strict {
		_, err := Validate(expected.Result.Type(), provided.Result.Type())

		if err != nil {
			return false
		}

		if len(expected.TypeParameters) != len(provided.TypeParameters) {
			return false
		}
	}

	// uneven parameter count
	if len(expected.Parameters) != len(provided.Parameters) {
		return false
	}

	for idx, prov := range provided.Parameters {
		ex := expected.Parameters[idx]

		// labels must match
		if prov.ParamLabel != ex.ParamLabel {
			return false
		}

		// types must match
		_, err := Validate(ex.Type(), prov.Type())

		if err != nil {
			return false
		}
	}

	return true
}
